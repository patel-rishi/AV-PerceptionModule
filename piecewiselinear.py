# -*- coding: utf-8 -*-
"""PieceWiseLinear.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OzRLzu-iq9OnlPzE-cnAmjdOgLup4dBv
"""

import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error

x = 3
if x==1: data = np.genfromtxt("/content/drive/MyDrive/Colab Notebooks/passenger_car.csv", delimiter=",")
elif x==2: data = np.genfromtxt("/content/drive/MyDrive/Colab Notebooks/motorcycle.csv", delimiter=",")
elif x==3: data = np.genfromtxt("/content/drive/MyDrive/Colab Notebooks/truck.csv", delimiter=",")
# Columns has headings: [YOLO distance, Carla distance, Predicted vehicle, Expected output, Testing]

data = data[1:] # Removing the headers
sorted_data = sorted(data, key=lambda a_entry: a_entry[0]) 
sorted_data = np.array(sorted_data)

# train, test = train_test_split(data, test_size=0.2, random_state=30)

# # TRAINING DATA
# # Getting expected distance
# x_train = np.array([train[x][0] for x in range(len(train))])
# # Getting YOLO distance
# y_train = np.array([train[x][3] for x in range(len(train))])

# # TESTING DATA
# # Getting expected distance
# x_test = np.array([test[x][0] for x in range(len(test))])
# # Getting YOLO distance
# y_test = np.array([test[x][3] for x in range(len(test))])

x_train = sorted_data[:,0][::3]
y_train = sorted_data[:,3][::3]

x_test = sorted_data[:,0][::2]
x_test = x_test[::4]
y_test = sorted_data[:,3][::2]
y_test = y_test[::4]

print(np.info(x_train))

from scipy import optimize
import matplotlib.pyplot as plt

n_lines = 2

def piecewise_linear_4(x, x0, x1, x2, b, k1, k2, k3, k4):
    condlist = [x < x0, (x >= x0) & (x < x1), x >= x1]
    funclist = [lambda x: k1*x + b, lambda x: k1*x + b + k2*(x-x0), lambda x: k1*x + b + k2*(x-x0) + k3*(x - x1), lambda x: k1*x + b + k2*(x-x0) + k3*(x - x1) + k4*(x-x2)]
    return np.piecewise(x, condlist, funclist)

def piecewise_linear_3(x, x0, x1, b, k1, k2, k3):
    condlist = [x < x0, (x >= x0) & (x < x1), x >= x1]
    funclist = [lambda x: k1*x + b, lambda x: k1*x + b + k2*(x-x0), lambda x: k1*x + b + k2*(x-x0) + k3*(x - x1)]
    return np.piecewise(x, condlist, funclist)

def piecewise_linear_2(x, x0, b, k1, k2):
    condlist = [x < x0, x >= x0]
    funclist = [lambda x: k1*x + b, lambda x: k1*x + b + k2*(x-x0)]
    return np.piecewise(x, condlist, funclist)

if n_lines == 2: p , e = optimize.curve_fit(piecewise_linear_2, x_train, y_train)
elif n_lines == 3: p , e = optimize.curve_fit(piecewise_linear_3, x_train, y_train)
elif n_lines == 4: p , e = optimize.curve_fit(piecewise_linear_4, x_train, y_train)
print(p)

xd = np.linspace(0, 20, 40)
plt.plot(x_train, y_train, "o")
if n_lines == 2: plt.plot(xd, piecewise_linear_2(xd, *p), color="red")
elif n_lines == 3: plt.plot(xd, piecewise_linear_3(xd, *p), color="red")
elif n_lines == 4: plt.plot(xd, piecewise_linear_4(xd, *p), color="red")

if x==1: plt.title("For PassengerCar")
elif x==2: plt.title("For Motorcycle")
else: plt.title("For Truck")
plt.xlabel("Estimated distance")
plt.ylabel("Carla ground truth distance")
plt.legend(["Training data", "Fitted line"])
plt.show()

print(f"{x_train[28]:.2f}")

from sklearn.metrics import mean_squared_error

# Prediction
def predict(xin):
  if n_lines == 2:
    if xin <= p[0]:
      return (p[2]*xin + p[1])
    else: 
      return (p[2]*xin + p[1] + p[3]*(xin-p[0]))
  elif n_lines == 3:
    if xin <= p[0]:
      return (p[3]*xin + p[2])
    elif xin > p[0] and xin <= p[1]: 
      return (p[3]*xin + p[2] + p[4]*(xin-p[0]))
    elif xin > p[1]:
      return (p[3]*xin + p[2] + p[4]*(xin-p[0]) + p[5]*(xin-p[1]))
  elif n_lines == 4:
    if xin <= p[0]:
      return (p[4]*xin + p[3])
    elif xin > p[0] and xin <= p[1]: 
      return (p[4]*xin + p[3] + p[5]*(xin-p[0]))
    elif xin > p[1] and xin <= p[2]:
      return (p[4]*xin + p[3] + p[5]*(xin-p[0]) + p[6]*(xin-p[1]))
    elif xin > p[2]:
      return (p[4]*xin + p[3] + p[5]*(xin-p[0]) + p[6]*(xin-p[1]) + p[7]*(xin-p[2]))

if n_lines == 2: 
  x_test1, x_test2, y_test1, y_test2, y_pred1, y_pred2 = [], [], [], [], [], []
  for index, item in enumerate(x_test):
    if item <= p[0]:
      x_test1.append(item)
      y_test1.append(y_test[index])
    else:
      x_test2.append(item)
      y_test2.append(y_test[index])
  for x in x_test1:
    y_pred1.append(predict(x))
  for x in x_test2:
    y_pred2.append(predict(x))
  print(mean_squared_error(y_test1, y_pred1))
  print(mean_squared_error(y_test2, y_pred2))
  print(np.var(np.array(y_pred1)-np.array(y_test1)))
  print(np.var(np.array(y_pred2)-np.array(y_test2)))
  
elif n_lines == 3: 
  x_test1, x_test2, x_test3, y_pred1, y_pred2, y_pred3 = [], [], [], [], [], []
  for x in x_test:
    if x <= p[0]:
      x_test1.append(x)
    elif x > p[0] and x <= p[1]: 
      x_test2.append(x)
    elif x > p[1]:
      x_test3.append(x)
  for x in x_test1:
    y_pred1.append(predict(x))
  for x in x_test2:
    y_pred2.append(predict(x))
  for x in x_test3:
    y_pred3.append(predict(x))
  # print(y_pred1)
  print(np.var(y_pred1))
  print(np.var(y_pred2))
  print(np.var(y_pred3))
elif n_lines == 4:
  x_test1, x_test2, x_test3, x_test4, y_pred1, y_pred2, y_pred3, y_pred4 = [], [], [], [], [], [], [], []
  for x in x_test:
    if x <= p[0]:
      x_test1.append(x)
    elif x > p[0] and x <= p[1]: 
      x_test2.append(x)
    elif x > p[1] and x <= p[2]:
      x_test3.append(x)
    elif x < p[2]:
      x_test4.append(x)
  for x in x_test1:
    y_pred1.append(predict(x))
  for x in x_test2:
    y_pred2.append(predict(x))
  for x in x_test3:
    y_pred3.append(predict(x))
  for x in x_test4:
    y_pred4.append(predict(x))
  print(np.var(y_pred1))
  print(np.var(y_pred2))
  print(np.var(y_pred3))
  print(np.var(y_pred4))

"""# New Section"""